<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>第一周考试题答案</title>    
</head>
<body>
	<h1>第一周考试题</h1>
	<pre>	
一 免费课基础知识练习  
   1、一维数组中都是数字，想实现数字的从大到小排序：
   	  <script type="text/javascript">
   	  		 arr=[19,8,07,14,6,1,3,21,5];
   	  		 arr.sort(function(a,b){
   	  		 	return a-b;
   	  		 });//[1, 3, 5, 6, 7, 8, 14, 19, 21]
   	  </script>
   2、删除数组中的最后一项内容，请至少写出三种办法
   	  <script type="text/javascript">
   	  		 arr=[19,8,07,14,6,1,3,21,5];
   	  		 //方法1
   	  		 arr.pop();
   	  		 console.log(arr);//[19, 8, 7, 14, 6, 1, 3, 21]
   	  		 //方法2
   	  		 arr.length--;
   	  		 console.log(arr);//[19, 8, 7, 14, 6, 1, 3]
   	  		 //方法3
   	  		 arr.splice(length-1,1);
   	  		 console.log(arr);//[19, 8, 7, 14, 6, 1]
   	  </script>
   3、找出数组中的第n项到第m项的内容：
     此题有歧义，arr[0]，没有明确索引0代表第0项还是第1项，此题答案则会不同。
      <script type="text/javascript">     
   		//1 如果索引0代表第1项目，那么索引n-1代表第n项，索引m代表第m+1项。包含第n不包含第m+1项。
   		slice(n-1,m); //包前不包后，截取第n到第m项
   		//2 如果索引0代表第0项目，那么索引n代表第n项，索引m+1代表第m+1项。包含第n项不包含第m+1项。
   		slice(n,m+1); //包前不包后，截取第n到第m项
      </script>
    4、获取当前浏览器可视区域的宽度(兼容所有的浏览器)：
      <script type="text/javascript">
      	  var h = document.documentElement.clientWidth||document.body.clientWidth; 
      </script>      
    5、把元素添加到指定的容器中，至少写出两种办法：
      <div id="oldNode" style="width:300px;height:300px,background-color:blue"></div>    
      <script type="text/javascript">
          var oldNode = document.getElementById("oldNode");
      	  var newNode = document.createElement("div");;
      	  newNode.style.width="400px";
      	  newNode.style.height="400px";
      	  newNode.style.backgroundColor="red";      	 
      	  //方法1
      	  document.body.appendChild(newNode);
      	  //方法2
      	  oldNode.parentNode.insertBefore(newNode,oldNode);
      </script>
 	6、获取上一个哥哥元素节点：
 	  <script type="text/javascript">
   		function preEle(currentEle){
			if(typeof currentEle.previousElementSibling =="object")			
				return currentEle.previousElementSibling;				
			var pre=currentEle.previousSibling;
			while(pre){
				if(pre.nodeType===1){
					return pre;
				}
				pre=pre.previousSibling;	
			}
			return null;//它没有哥哥元素则返回null。			
		}
   	  </script>
 	7、获取[n-m]之间的随机整数：
 	  <script type="text/javascript">
 	  	 function getRandom(n, m) {
        	n = Number(n);
        	m = Number(m);
        	if (isNaN(n) || isNaN(m)) {
            	return Math.random();
        	}
        	if (n > m) {
            	var temp = n;
            	n = m;
            	m = temp;
        	}
        	return Math.round(Math.random() * (m - n) + n);
    	}
 	  </script>
 	8、把字符串中的某一个字符进行替换：
 	  <script type="text/javascript">
 	  	  var str="wife knife";
          str.replace("fe","ves"); //"wives knife";
          var reg=/fe/g;                
          str.replace(reg,"ves"); //"wives knives";               
          function fn(match){
              return "ves";
          }
          str.replace(reg,fn); //"wives knives";  
          console.log(str);  //"cake wake"
 	  </script>
 	9、<div id=’tab’class=’tabCon’></div>:用js获取着这一个元素对
 	  <script type="text/javascript">
 	  	  document.getElementById("tab")；
          document.getElementsByClassName("tabCon")[0]；      
          document.getElementsByTagName("div")[0]；
          document.querySelector("#tab/.tabCon/div")
 	  </script>
    10、[]==false：_____   ![]==false：_____
      10.1 对象类型和布尔类型比较两边都转化成数字类型再比较
           []转成成字符串类型结果为空字符串""，空字符串转化成数字为0
           false转换成数字结果为0
           []==false结果为true
      10.2 布尔类型和布尔类型直接比较
           任何数据类型前面加!就是布尔类型
           []转成布尔类型为true,![]为false
           ![]==false结果为true
二、根据每一道题的代码写出正确的输出结果 (60分)  
    1 if语句不管条件会否成立都会对带var关键字的进行声明，"num" in window判断是否存在全局变量num	   
	    以下代码执行步骤：
	       1.1 先声明带var和带function关键字的全局变量(不管if条件是否成立，都会进行var声明)           
	            var num;//忽略条件判断，首先声明全局变量var a  
	       1.2 从上到下执行代码
	           1.2.1  console.log(num);//undefined， num已经声明过但未赋值，所以弹出undefined
	           1.2.2 "num" in window
	                 "num" in window //true, 1.1 中已经声明过全局变量num，即给window添加了属性num，window.num存在
	                 num=12;
	           1.2.3  console.log(num);//12， num已经被赋值为12     
	     <script type="text/javascript">
	         console.log(num);//undefined
	     	 if("num" in window){
			      var num=12;
			  }
			 console.log(num);//12
	     </script>  
	     最终输出结果为：
	     undefined
	     12
	2 自执行函数函数中的this是window,a||b当a为true时取a的值否则当a为false时取b的值	  
      以下代码执行步骤：
	       2.1 先声明带var和带function关键字的全局变量           
	            var num;
	            var age;
	            自执行函数里是代码字符串
	       1.2 从上到下执行代码
	           1.2.1 name = "china";
	           1.2.2 age = 5000;
	           1.2.3 执行自执行函数
	                 1.2.3.1 观察是否有形参，函数体内是否有待var和function关键紫的
	                 1.2.3.2 将实参全局name的值传给形参私有变量name=window.name="china";
	                 1.2.3.3 修改第一个参数的值name=arguments[0]="zhuFeng";
	                 1.2.3.4 age = age||this.age=this.age=window.age=5000;
	                 1.2.3.5 window.name=this.name=name="zhuFeng";
	                 1.2.3.6 console.log(name,age);//"zhuFeng" 5000
	           1.2.4 console.log(name,age);//"zhuFeng" 5000	          
	     <script type="text/javascript">
	  		var name = "china";
	  		var age = 5000;
	  		~function (name,age){
	  			arguments[0]="zhuFeng";
	  			age=age||this.age;
	  			this.name=name;
	  			console.log(name,age);
	  		}(name);
	  		console.log(name,age);
	    </script>
	     最终输出结果为：
	     "zhuFeng" 5000
	     "zhuFeng" 5000
    3  当在一个外部函数中返回一个内部函数并赋值给一个全局变量时，外部涵数产生的私有作用域不销毁。       
       3.1 先声明带var和带function关键字的全局变量
             3.1.1 var i; //声明带var关键字的
             3.1.2 声明带function关键字的，如果没有等号，则会进行提前定义。
                     函数虽然提前进行了声明并定义（赋值），但是函数体内存储的是代码字符串。
		              function fn(){ 
		                  " return function(n){ console.log(n+i++); }   "	     			            			 
				      }
		      3.1.3  var f; //声明带var关键字的		            
        3.2 从上到下执行代码           
            3.2.1 i=10;// 因为3.1.1中已经var i声明过i（变量提升，提前声明），这行代码不需要重复声明，只进行赋值操作i=10;
            3.2.2 直接跳过fn函数，因为3.1.2中已经声明并定义过了。                   
		    3.2.3 f=fn(i);//执行fn(i);此时fn函数体内的代码字符串变成可执行的代码,并将返回值赋值给变量f
		         function fn(i){ 
				  	return function(n){ console.log(n+i++); }   
			     }
		         3.2.3.1 看函数是否有形参，如果有则声明为私有变量，如果没有则继续下一步。
		                 存在形参i
		         3.2.3.2 声明函数体内带var和带function关键字的作为私有变量,如果没有则继续下一步		                  
		                  function (n){//返回匿名函数，此时匿名函数内是代码字符串，不是可执行代码
		                      "
		                      	console.log(n+i++);
		                      "							  
					      }		
			     3.3.3.3 对形参进行赋值i=10;                
		    3.2.4 f(10);//执行f(10);此时f函数体内的代码字符串变成可执行的代码
		          return function(n){ return n+i++; }
		          3.2.4.1 看函数是否有形参，如果有则声明为私有变量
		                  形参n，生为私有变量n
		                  n=10; //f(10)；将私有变量n的值赋值为10
		          3.2.4.2 声明函数体内带var和带function关键字的作为私有变量,如果没有则继续下一步
		                 n+(++i);//21，私有变量n的值为10，全局变量n的值在3.3.3.3已经被赋值为10。 n+(++i)，n先自增再运算，i自增变成11，10+11的值为21故返回21.
		    3.2.5 f(20);//执行f(20);此时f函数体内的代码字符串变成可执行的代码
		          f指向的同一个外部函数的返回值，共享同一私有变量i。
		          3.2.4中i的值已经为11
		          ++i变成12。
		          所以f(20)返回20+12=32;
		    3.2.6 fn(i)(10);//先执行fn(i);再执行fn(i)的返回函数并将第一个参数的值赋值为10
		         重新执行fn会开辟新的内存空间，而且会重新初始化私有变量i的值为10.
                 重复3.2.3和3.2.4，输出结果为21.
            3.2.7 fn(20)(20);//先执行fn(20);再执行fn(20)的返回函数并将第一个参数的值赋值为20
		         重新执行fn会开辟新的内存空间，而且会重新初始化私有i的值为20.
                 重复3.2.3和3.2.4，输出结果为41.
     <script type="text/javascript">
       		var i=10;
       		function fn(i){
       			return function(n){
       				console.log(n+(++i));
       			}
       		}
       		var f=fn(i);
       		f(10);
       		f(20);
       		fn(i)(10);
       		fn(20)(20);
       </script>
	 最终输出结果为：
	     21
	     32
	     21
	     41	    
	4  自执行函数中的this为window,不带前缀的变量名沿着作用域链逐级向上查找直到找到为止。 
       4.1 先声明带var和带function关键字的全局变量
             4.1.1 var num; //声明带var关键字的
                   var obj; //声明带var关键字的
                   var fn; //声明带var关键字的
             4.1.2 声明带function关键字的，如果没有则下一步。
       4.2 从上到下执行代码           
            4.2.1 num=10;// 因为4.1.1中已经var i声明过num（变量提升，提前声明），这行代码不需要重复声明，只进行赋值操作num=10;
            4.2.2 obj赋值
                  4.2.2.1 obj.num=10;
                  4.2.2.2 obj.fn赋值
                          4.2.2.2.1 执行自执行函数。传入的实参num是window下的num=10
                          4.2.2.2.2 将来实参num=10的值赋给形参num,使得自执行函数的私有变量num=10  
                          4.2.2.2.3 自执行函数中的this指向window
                                    返回的内部函数中的this执行的时候才能确定。
                                    自执行函数包括返回的内部函数中的不带前缀的num都是指私有变量num
                                    window.num = this.num = num+10=10+10=20;//全局变量num变成20
                          4.2.2.2.4 num+=10-->num=num+10=20; //私有变量num变成20；
                          4.2.2.2.5  返回内部函数赋值给obj.fn
				                  obj.fn = function(){
				                  		this.num = num+10;
				                  		num++;
				                  		console.log(num);
				                  }
		    4.2.3 fn=obj.fn;//fn和obj.fn此时都指向同一个内部函数的引用，意味着共享同一个私有变量num
		    4.2.4 fn();//fn中的this是window
		          4.2.4.1 window.num=this.num=num+10=20+10=30;
		                  自执行函数包括返回的内部函数中的不带前缀的num都是指私有变量num
		                  4.2.2.2.4 中私有变量num的值已经变成20.
		          4.2.4.2 num++;//21,私有变量num的值变成21
		          4.2.4.3 console.log(num);//21,输出私有变量的值21
		    4.2.5 obj.fn();//fn中的this变成obj
		         fn和obj.fn此时都指向同一个内部函数的引用，意味着共享同一个私有变量num		       
		         重复执行4.2.4中的步骤
		         4.2.5.1 obj.num=this.num=num+10=21+10=31;
		                  自执行函数包括返回的内部函数中的不带前缀的num都是指私有变量num
		                  4.2.4.2 中私有变量num的值已经变成22.
		         4.2.5.2 num++;//22,私有变量num的值变成22
		         4.2.5.3 console.log(num);//22,输出私有变量的值22
		    4.2.6 console.log(num);//30
		          4.2.4.1 中全局变量num的值最终变为30
		    4.2.7 console.log(obj.num);//31
		          4.2.5.1 中obj.num的值最终变为31           
     <script type="text/javascript">
       		var num=10;
       		var obj = {
       			num:10,
       			fn:(function (num){
       				this.num = num +10;
       				num +=10;
       				return function(){
       					this.num = num+10;
       					num++;
       					console.log(num);
       				}
       			})(num)
       		}
       		var fn = obj.fn;
       		fn();
       		obj.fn();
       		console.log(num);
       		console.log(obj.num);
       </script>
	 最终输出结果为：
	     21
	     22
	     30
	     31	 
	  5 按引用传递，当实参为引用数据类型时，形参跟实参指向同一个引用地址，修改一个变量的属性值会影响另一个变量。
	    但是如果将一个变量重新赋值，则断开了链接，从此互不影响。   
        以下代码执行步骤：
	       5.1 先声明带var和带function关键字的全局变量           
	            var ary;	           
	            自执行函数里是代码字符串
	       5.2 从上到下执行代码
	           5.2.1 ary=[12,23];//	[12,23]存储在堆内存空间xxxfff000,全局变量ary存储的是引用地址xxxfff000       
	           5.2.2 执行自执行函数
	                 5.2.2.1 观察是否有形参，函数体内是否有待var和function关键紫的
	                 5.2.2.2 将实参全局name的值传给形参私有变量ary=window.ary=[12,23];
	                         私有变量存储的是引用地址xxxfff000	              
	                 5.2.3.3 ary.length-=1;//删除私有变量和全局变量ary的最后一项
	                         此时私有变量和全局变量ary指向的堆内存空间对应的值均变成ary[12];
	                         堆内存空间xxxfff000存储的值变成[12];
	                 5.2.3.4 ary=[34];//堆内存空间xxxfff111对应的值为[34]	                         
	                         私有变量ary指向一个新的引用地址xxxfff111对应的值为[34]
	                         全局变量window.ary依然指向原来的引用地址xxxfff000对应的值为[12]
	                 5.2.3.5 ary.length-=1;
	                         私有变量arry删除最后一个元素也是唯一个元素后值变成空数组[]
	                         全局变量window.ary的指向不同的引用地址不受影响，对应的值依然为[12]
	                 5.2.3.6 alert(ary);//弹出空字符串""
	                         5.2.3.5中私有变量ary的值已经变成空数组[]
	                         alert会调用toString方法，[].toString()会被转换成空字符串""	                
	           5.2.3 alert(ary);//"12" 
	                 全局变量ary的值为[12]
	                 alert会调用toString方法后再输出，[12].toString();返回"12"        
	     <script type="text/javascript">
	  		var ary = [12,23];	  		
	  		~function (ary){
	  			ary.length-=1;
	  			ary=[34];
	  			ary.length-=1;	  		
	  			alert(ary);
	  		}(ary);
	  		alert(ary);
	    </script>
	     最终输出结果为：
	     ""
	     "12"
	6 构造函数中的this是构造函数的实例对象，	 
	  <script type="text/javascript">      
        //构造函数Fn体内部定义的带this前缀的属性和方法，是构造函数Fn和实例new Fn的私有方法，Fn和f都能访问到
        function Fn() {
            this.x = 100;
            this.y = 200;  
        }
        //在Fn的原型Fn.prototype上添加的属性和方法，是公有属性和方法。Fn的实例f可以访问到
        Fn.prototype.getX=function () {
                console.log(this.x);
        }
        Fn.prototype={
         	getY:function () {
                console.log(this.y);
            }
        }
        //通过new Fn方式创建的是Fn的实例f，自动拥有Fn构造函数内定义的带this前缀的属性和方法this.x、this.y和this.getX。
        var f = new Fn;          
        console.log(f.getY === Fn.prototype.getY);  //true，实例f上不存在私有方法getX,沿着原型链向上查找最终找到公有方法  Fn.prototype.getY，二者指向同一个方法故相等。      
        //f.getX();   // 报错,f上不存在getX方法，所属类Fn上不存在带this的方法this.getX,原型链Fn.prototype上也不存在getX方法，执行不存在的方法
        f.getY();  //200，f1上没有getY方法，向上查找找到原型上的getY,getY方法内的this指向f1,this.y=f1.y=200
        f.__proto__.getY(); //undefined,等价于Fn.prototype.getY(),getY方法中的this指向Fn.prototype,但是Fn.prototye.y不存在，所以undefined       
        console.log(f.constructor);//Object，因为f没有contructor属性，Fn.prototype被重新赋值后失去了contructor属性，最终访问的是Object.prototype.contructor，指向Object本身        
    </script>
     最终输出结果为：
	     true
	     报错
	     200
	     undeFined
	     Object
三：问答题 （20分）
有如下的HTML结构，需求是想要实现点击每一个按钮，让body的背景颜色显示不同的，请问下面代码是否可以实现？并写出至少两种不同思路的解决办法？
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>变色</title>   
</head>
<body>
<input type="button" value="红色"/>
<input type="button" value="黄色"/>
<input type="button" value="绿色"/>
<script type="text/javascript">
	   var ary = ['red', 'yellow', 'green'];
       var oBtns = document.getElementsByTagName("input");
        for (var i = 0; i < oInps.length; i++) {
            var oBtn = oBtns[i];
             //方法1：自定义属性（推荐）
            oBtn.index = i;           
            oBtn.onclick = function () {
                document.body.style.backgroundColor = ary[this.index];
            }
            //方法2：闭包,ary[i]的上级作用域是自执行函数，ary[i]的索引i是自执行函数的私有变量i
            /*
             oBtn.onclick = (function (i) {           
	           return function () {
	                document.body.style.backgroundColor = ary[i];
	           }
	        })(i);
	        */
	        //方法3：闭包,ary[i]的上级作用域是自执行函数，ary[i]的索引i是自执行函数的私有变量i
	        /*
	         ~function (i) {       
	            oBtn.onclick = function () {
	                 document.body.style.backgroundColor = ary[i];
	            }
	        }(i);
	        */
        }
</script>
</body>
</html> 


  
	</pre>
  </body>
</html>
