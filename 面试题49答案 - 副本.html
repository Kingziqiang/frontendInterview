<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>面试题51答案</title>    
</head>
<body>
	<h1>51 什么是预解释？window全局作用域下带var和不带var的变量有何区别？什么是作用域？函数执行的步骤？什么是私有变量？写出面试题50中第四大题（考察数据类型转换规则的填空题）和第九大题（360面试题）的分析步骤。</h1>
	<pre>	
一、什么是预解释？
  1、什么是预解释？
    在当前作用域下，JS代码执行之前，首先会把带var/function关键字的进行提前的声明（declare）或者定义（defined）。
  2、预解释是如何操作的？
    2.1.带var关键字的在预解释阶段只完成了提前的声明；
    2.2.带function关键字的在预解释阶段完成了声明和定义两个操作。
  3、预解释的注意点?
    3.1.不管条件判断是否成立，判断体中的内容都要进行预解释；
　　　例如：if (!('a' in window)) {
　　　　　　var a=12; //判断'a'是否为window的一个属性名，因为预解释的时候声明了'a'，所以为true，取反为false，条件不成立，a=12执行不了，输出a=undefined；
　　　　　　}
    3.2.预解释的时候只对"="等号左边的变量进行预解释，右边代表的都是值，是不进行预解释的；
	　例1：fn();  //可以在函数前面执行，因为在预解释的时候，fn声明和定义都完成了
	　　　 function fn(){ 
	　　　　　console.log('ok');
	　　　 }
	　例2：fn();　//这样就会报错fn is not a unction，因为在预解释的时候只是对等号左边的值进行了预解释，此时fn的值是undefined，不是一个函数，不能执行　
	　　　 var fn=function(){ 
	　　　　  console.log('ok');
	　　　}	                       
  4、在全局作用域下预解释的时候，自执行函数中的function是不参与的，当代吗执行到对应的区域后，声明、定义、执行一起完成；
  5、虽然函数体中return下面的代码是不执行的，但是需要进行私有作用域下的预解释，而return后面的是返回值，是不进行预解释的；
　　例如：var a=1;
　　　　　function fn(){
　　　　　    console.log(a);   //私有作用域下的预解释，首先在私有作用域中var a，说明a是私有变量，但是return下面的代码不执行，所以a为undefined;
　　　　      return function(){  };   // return后面的不进行预解释，返回的是这个函数对应的地址；
　　　　　    var a=10;
　　　　　}
　　　　fn();  
  6、在预解释的时候，如果发现名字冲突了，不需要重新声明，但是需要重新的赋值。（在JS中不管是变量还是函数，只要名字一样了，就是相互冲突，JS中一个名字就代表一个变量，只不过存储的值可以是任意数据类型的）
　　在全局作用域下不管是声明变量还是定义函数，都是在给window增加属性名。
 　　例如：fn();  //输出结果2
　　　　　 function fn(){ console.log(1); }
　　　　　 fn();  //输出结果2
　　　　 　var fn=13;
　　　　 　fn();   //报错
　　　　　 function fn(){ console.log(2); }
　　　　　 fn();   //输出结果2

二、window全局作用域下带var和不带var的变量有何区别
	1 带var的可以在代码执行之前进行预解释(提升），而不带var的是不能进行预解释（提升）的.
    2 带var的全局变量不能被删除，不带var的全局变量可以被删除。
      因为delete智能删除对象的可删除的属性，而通过var 定义的全局属性会被标明不可删除。
      需要说明的是，delete不成功并不会抛错，delete的返回值是true|false。
      举例如下：
       var a=1;
       delete a; //返回false，删除失败
       console.log(a);//1，因为a删除失败，所以依然能够正常输出a的值。
       b=2;
       delete b; //返回true，删除成功
       console.log(b); //报错，未定义错误，因为b已经被删除成功。
       
三、什么是作用域
    我们把供JS代码执行的环境称之为"作用域"
    它是指对某一变量和方法具有访问权限的代码空间, 在JS中, 作用域是在函数中维护的. 
    表示变量或函数起作用的区域，指代了它们在什么样的上下文中执行，亦即上下文执行环境。Javascript的作用域只有两种：全局作用域和本地作用域，本地作用域是按照函数来区分的。

四、函数执行的步骤   
	1、形成私有的作用域：当函数执行的时候，首先会提供一个供函数体中代码执行的环境，我们把它称之为私有的作用域
    2、给形参赋值：在代码执行之前，我们给函数中的形参变量进行赋值
    3、进行私有作用域下的预解释：把私有作用域中的带var和带function的进行提前的声明加定义
    4、私有作用域中的代码从上到下执行

五、什么是私有变量
    在私有作用域中的"形参"和"声明过的变量"都是私有的变量，而且私有变量有且只有这两种情况
    函数执行的时候，形成的那个私有作用域不仅可以供JS代码执行，而且还可以保护函数体中的私有变量不受外界的干扰--->我们把函数的这种保护机制叫做"闭包"

六、写出面试题50中第四大题（考察数据类型转换规则的填空题）的分析步骤
    1 []==false：____________   // true
      对象类型和布尔类型比较时，两边都转化成数字类型，然后再进行比较。
      Number([]) -->  根据面试题28答案中对象类型转换成数字类型的规律，结果为0
      Number(false) --> 根据面试题28答案中布尔类型转换成数字类型的规律，结果为0
      因为0==0成立，结果为true.
    2 ![]==false：____________   //true
      两边都是布尔类型
      左边![]等价于!Boolean([])
      Boolean([]) --> 根据面试题28答案中其他数据类型转换成布尔类型的规律，对象类型转换结果都为true
      Boolean([])取反！Boolean([])为false，即![]为false。
      两边都是false,故比较结果为true。
    3 []==![]：______________   // true
      根据第2题的结论，![]转换结果为false。
      问题等价于[]==false
      根据第1题的积累，最终比较结果为true
    4 Number(“13px”)==NaN：___________  //false
      根据面试题28答案中字符串类型转换成数字类型的规律，包含非有效数字的字符串（浮点数和十六制数字除外）转化结果为NaN.
    5 5+”3”-2：___________________  //51
      回顾《面试题36 乘法、除法、求模、加法、减法操作符的规则。》
      字符串参与加法运算直接进行字符串拼接
      字符串减法运算将字符串强制转换成数字类型，然后进行数字减法运算。
    6 If(“3px”*3){alert(“true”)}else{alert(“false”)}：____________ // “false”
      回顾《面试题36 乘法、除法、求模、加法、减法操作符的规则。》
      非有效数字参与乘法运算会强制转换数字类型，然后参与运算。
      Number("3px") 结果为NaN,NaN*3结果为NaN.
      If语句中的条件会转换成布尔类型，NaN转换成布尔类型结果为false。
      If条件不成立，则执行false语句，弹出字符串"false"。
    7 If(“3px”+3){alert(“true”)}else{alert(“false”)}：___________ // “true”
      回顾《面试题36 乘法、除法、求模、加法、减法操作符的规则。》
      字符串参与加法会直接进行字符串拼接操作。
      “3px"+3结果为"3px3","3px3"转换成布尔类型结果为true.    
      If条件成立，则执行If语句，弹出字符串"true"。
    8 If（document.body）{alert(“ok”);}else{alert(“no”)}：_______________ // “ok”
      documnent.body代表body元素，是对象类型。
      对象类型转换成布尔类型结果为true.
       If条件成立，则执行If语句，弹出字符串"ok"。
    9 alert([])：______________  “”   
      alert方法中的参数会调用toString()方法，转换成字符串类型后弹出。
      [].toString()结果为空字符串""
      故最终弹出空字符串""
    10 null==undefined：________________  //true
      null与undefined比较结果为true

七、写出面试题50中第九大题（360面试题）的分析步骤。
    360面试题：
      var ary=[1,2,3,4];
      function fn(ary){ //形参ary是函数内部的私有变量，不同于外部全局变量ary，但是私有变量ary和全局变量ary指向同一个引用地址xxxfff0001
          ary[0]=0;   //修改引用地址xxxfff001对应的数组[1,2,3,4]第0个元素的值，故全局变量ary变成[0,2,3,4] 
          ary=[0];    //将私有变量ary指向新的引用地址xxxaaa002,引用地址xxxaaa002对应的堆内存空间存储数组[0]
          ary[0]=100; //修改xxxaaa002对应的数组[0]的第0个元素，故私有变量ary变成[100],并不影响全局变量ary的值，因为二者上一步已经指向不同的地址。  
          return ary; //返回私有变量ary的值[100]给res
      }
      var res=fn(ary); //将全局变量ary对应的引用地址xxxfff001作为实参传给方法fn的形参私有变量ary，
      console.log(ary); //[0,2,3,4]
      console.log(res); //[100]

    形参跟实参同名，外部全局变量与函数内部私有变量同名，容易造成混淆，此题的等价写法如下：
     var ary=[1,2,3,4];
      function fn(inArr){ //形参inArr是函数内部的私有变量，不同于外部全局变量ary，但是私有变量inArr和全局变量ary指向同一个引用地址xxxfff0001
          inArr[0]=0;   //修改引用地址xxxfff001对应的数组[1,2,3,4]第0个元素的值，故全局变量ary变成[0,2,3,4] 
          inArr=[0];    //将私有变量ainArr指向新的引用地址xxxaaa002,引用地址xxxaaa002对应的堆内存空间存储数组[0]
          inArr[0]=100; //修改xxxaaa002对应的数组[0]的第0个元素，故私有变量inArr变成[100],并不影响全局变量ary的值，因为二者上一步已经指向不同的地址。  
          return inArr; //返回私有变量inArr的值[100]给res
      }
      var res=fn(ary); //将全局变量ary对应的引用地址xxxfff001作为实参传给方法fn的形参私有变量inArr，
      console.log(ary); //[0,2,3,4]
      console.log(res); //[100]
